import streamlit as st
import PyPDF2
import re
import os
import json
import firebase_admin
from firebase_admin import credentials, firestore
from langchain_community.llms import HuggingFaceHub  
from langchain_core.prompts import ChatPromptTemplate
from dotenv import load_dotenv

load_dotenv()

# ğŸ”¹ CONFIGURAÃ‡ÃƒO DO FIREBASE
if not firebase_admin._apps:
    if os.getenv("STREAMLIT_CLOUD"):
        firebase_credentials = json.loads(st.secrets["FIREBASE"])
        cred = credentials.Certificate(firebase_credentials)
    else:
        cred = credentials.Certificate("firebase_key.json")

    firebase_admin.initialize_app(cred)

db = firestore.client()

# ğŸ”¹ CONFIGURAÃ‡ÃƒO DO HUGGING FACE
huggingface_api_token = os.getenv("HUGGINGFACE_API_TOKEN")
if not huggingface_api_token:
    raise ValueError("A chave da Hugging Face nÃ£o foi carregada! Verifique o .env ou as variÃ¡veis de ambiente.")

def model_hf_hub(model="meta-llama/Meta-Llama-3-8B-Instruct", temperature=0.1):
    return HuggingFaceHub(
        repo_id=model,
        huggingfacehub_api_token=huggingface_api_token,  
        model_kwargs={
            "temperature": temperature,
            "return_full_text": False,
            "max_new_tokens": 512
        }
    )

# ğŸ”¹ FUNÃ‡ÃƒO PARA CARREGAR NORMATIVOS DO FIRESTORE
def carregar_normativos():
    try:
        docs = db.collection("normativos").stream()
        normativos = {doc.id: doc.to_dict().get("conteudo", "") for doc in docs}
        return normativos if normativos else {}  
    except Exception as e:
        st.sidebar.error(f"Erro ao carregar normativos: {e}")
        return {}  

# ğŸ”¹ EXTRAÃ‡ÃƒO DE TEXTO DE PDF
def extrair_texto_pdf(pdf_file):
    try:
        reader = PyPDF2.PdfReader(pdf_file)
        text = "\n".join(page.extract_text() for page in reader.pages if page.extract_text())
        return text
    except Exception as e:
        st.error(f"Erro ao ler o PDF: {e}")
        return ""

# ğŸ”¹ CARREGAMENTO DE NORMATIVOS
normativos_carregados = carregar_normativos()

# ğŸ”¹ CONFIGURAÃ‡ÃƒO DA PÃGINA
st.set_page_config(page_title="Validador e Pesquisa de Normativos", page_icon="ğŸ“œ", layout="wide")

# ğŸ”¹ Exibir status do banco de dados
if normativos_carregados:
    st.sidebar.success("âœ… Normativos salvos no banco de dados!")
    with st.sidebar.expander("ğŸ“‚ **Ver Normativos no Banco**", expanded=False):
        for nome in normativos_carregados.keys():
            st.write(f"- ğŸ“œ {nome}")
else:
    st.sidebar.warning("âš ï¸ Nenhum normativo encontrado. Por favor, faÃ§a o upload.")

# ğŸ”¹ UPLOAD DE NOVOS NORMATIVOS
uploaded_normativos = st.sidebar.file_uploader("ğŸ“‚ Enviar Normativos (PDF)", accept_multiple_files=True)
if uploaded_normativos:
    for file in uploaded_normativos:
        nome = file.name
        conteudo = extrair_texto_pdf(file)
        db.collection("normativos").document(nome).set({"conteudo": conteudo})

    st.sidebar.success("âœ… Normativos salvos no banco de dados!")
    normativos_carregados = carregar_normativos()

# ğŸ”¹ UPLOAD DE TR E ETP
uploaded_tr = st.sidebar.file_uploader("ğŸ“‘ Envie o Termo de ReferÃªncia (PDF)", type="pdf")
uploaded_etp = st.sidebar.file_uploader("ğŸ“„ Envie o Estudo TÃ©cnico Preliminar (PDF)", type="pdf")

# ğŸ”¹ ENTRADA DE PESQUISA (CORRIGIDO)
pesquisa_usuario = st.text_input("ğŸ” Pesquisar nos normativos")

# ğŸ”¹ Verifica se o usuÃ¡rio digitou uma pesquisa
if pesquisa_usuario:
    resposta_completa = ""
    fontes_utilizadas = []

    filtro_normativos = {
        "decreto 44330": "Decreto 44330 de 16_03_2023.pdf",
        "lei 14133": "L14133.pdf",
        "instruÃ§Ã£o normativa 94/22": "InstruÃ§Ã£o Normativa n94-22.pdf",
        "instruÃ§Ã£o normativa 65/21": "INSTRUÃ‡ÃƒO NORMATIVA n 65-21.pdf"
    }

    normativo_escolhido = None
    for termo, arquivo in filtro_normativos.items():
        if termo in pesquisa_usuario.lower():
            normativo_escolhido = arquivo
            break

    if normativo_escolhido and normativo_escolhido in normativos_carregados:
        texto_normativo = normativos_carregados[normativo_escolhido]
        prompt_template = ChatPromptTemplate.from_template(
            f"ğŸ“œ **{normativo_escolhido}**:\n{texto_normativo[:4000]}\n\n"
            f"**Pergunta:** {pesquisa_usuario}\n"
            f"**Resposta:**"
        )
        llm = model_hf_hub()
        resposta = llm(prompt_template.format(input=pesquisa_usuario))
        resposta_completa = f"ğŸ“œ **Fonte:** {normativo_escolhido}\n\n{resposta}"
        fontes_utilizadas.append(normativo_escolhido)

    st.subheader("ğŸ¤– Resposta do Assistente")
    if resposta_completa:
        st.write(resposta_completa)
    else:
        st.warning("âŒ Nenhuma informaÃ§Ã£o relevante encontrada nos normativos.")

# ğŸ”¹ CONFIGURAÃ‡ÃƒO DO CHECKLIST (NÃƒO FOI ALTERADO)
st.title("ğŸ“œ Validador de Termo de ReferÃªncia e Estudo TÃ©cnico Preliminar")
st.write("O sistema verifica se os documentos atendem Ã s exigÃªncias legais e normativas.")

checklist_tr = {
    "DefiniÃ§Ã£o do Objeto": "DefiniÃ§Ã£o do Objeto|Objeto da ContrataÃ§Ã£o|Objeto",
    "Justificativa": "Justificativa|DescriÃ§Ã£o da Necessidade",
    "FundamentaÃ§Ã£o Legal": "FundamentaÃ§Ã£o Legal|Base Legal|FundamentaÃ§Ã£o",
    "EspecificaÃ§Ãµes TÃ©cnicas": "EspecificaÃ§Ãµes TÃ©cnicas|EspecificaÃ§Ãµes do Objeto|Das EspecificaÃ§Ãµes do Objeto",
    "CritÃ©rios de AceitaÃ§Ã£o": "CritÃ©rios de AceitaÃ§Ã£o|Aceite",
    "Modelo de ExecuÃ§Ã£o do Objeto": "Modelo de ExecuÃ§Ã£o do Objeto|CondiÃ§Ãµes de execuÃ§Ã£o|ObrigaÃ§Ãµes da Contatada|ObrigaÃ§Ãµes da Contratante",
    "Modelo de GestÃ£o do Contrato": "Modelo de GestÃ£o do Contrato|Preposto|FiscalizaÃ§Ã£o",
    "Pesquisa de PreÃ§os": "Pesquisa de PreÃ§os|Estimativa de Custos|Estimativa de PreÃ§os|PreÃ§os Referenciais",
    "Resultados Esperados": "Resultados Esperados|Metas|Impactos Esperados",
    "ClassificaÃ§Ã£o de Bem Comum": "ClassificaÃ§Ã£o de Bem Comum|ClassificaÃ§Ã£o|Bem Comum",
    "Garantia": "Garantia|AssistÃªncia TÃ©cnica|VigÃªncia Contratual|VigÃªncia",
    "Garantia Contratual": "Garantia Contratual",
    "CritÃ©rios de MediÃ§Ã£o e Pagamento": "CritÃ©rios de MediÃ§Ã£o e Pagamento|Pagamento|Do Pagamento",
    "Parcelamento do Objeto": "Parcelamento do Objeto|Parcelamento|Do Parcelamento",
}

checklist_etp = {
    "IntroduÃ§Ã£o": "IntroduÃ§Ã£o|Objeto",
    "DescriÃ§Ã£o da Necessidade": "DescriÃ§Ã£o da Necessidade|MotivaÃ§Ã£o|Justificativa|Detalhes|DescriÃ§Ã£o|Necessidade da ContrataÃ§Ã£o",
    "DefiniÃ§Ã£o e EspecificaÃ§Ã£o dos Requisitos": "DefiniÃ§Ã£o e EspecificaÃ§Ã£o dos Requisitos|DefiniÃ§Ã£o e EspecificaÃ§Ã£o das Necessidades e Requisitos|EspecificaÃ§Ã£o do Objeto|DescriÃ§Ã£o da SoluÃ§Ã£o",
    "Alternativas de Mercado": "Alternativas de Mercado|Alternativas do Mercado|Levantamento de Mercado",
    "Detalhamento da SoluÃ§Ã£o": "Detalhamento da SoluÃ§Ã£o|SoluÃ§Ã£o",
    "Justificativa da SoluÃ§Ã£o Escolhida": "Justificativa da SoluÃ§Ã£o Escolhida|Justificativa do CenÃ¡rio Escolhido|Justificativa Final",
    "Pesquisa de PreÃ§os": "Pesquisa de PreÃ§os|Estimativa de Custos|Estimativa do Custo Total",
    "Alternativas Analisadas": "Alternativas Analisadas|Alternativas de Mercado|Fontes",
    "Viabilidade TÃ©cnica e EconÃ´mica": "Viabilidade TÃ©cnica e EconÃ´mica|DeclaraÃ§Ã£o de Viabilidade|Viabilidade da ContrataÃ§Ã£o",
}

# ğŸ”¹ FunÃ§Ã£o para verificar checklist
def verificar_checklist(texto, checklist):
    return {pergunta: bool(re.search(referencia, texto, re.IGNORECASE)) for pergunta, referencia in checklist.items()}

# ğŸ”¹ Definir listas vazias antes da verificaÃ§Ã£o
faltantes_tr, faltantes_etp = [], []

# ğŸ”¹ Verifica o TR e o ETP separadamente
if uploaded_tr:
    tr_texto = extrair_texto_pdf(uploaded_tr)
    st.success("ğŸ“‘ Termo de ReferÃªncia carregado! Analisando...")
    checklist_resultados_tr = verificar_checklist(tr_texto, checklist_tr)
    faltantes_tr = [item for item, presente in checklist_resultados_tr.items() if not presente]

if uploaded_etp:
    etp_texto = extrair_texto_pdf(uploaded_etp)
    st.success("ğŸ“„ Estudo TÃ©cnico Preliminar carregado! Analisando...")
    checklist_resultados_etp = verificar_checklist(etp_texto, checklist_etp)
    faltantes_etp = [item for item, presente in checklist_resultados_etp.items() if not presente]

# ğŸ”¹ Exibir checklist do TR
if uploaded_tr:
    st.subheader("ğŸ“‹ Checklist do Termo de ReferÃªncia")
    for pergunta, presente in checklist_resultados_tr.items():
        st.write(f"- {pergunta}: {'âœ… Presente' if presente else 'âŒ Ausente'}")

# ğŸ”¹ Exibir checklist do ETP
if uploaded_etp:
    st.subheader("ğŸ“‹ Checklist do Estudo TÃ©cnico Preliminar")
    for pergunta, presente in checklist_resultados_etp.items():
        st.write(f"- {pergunta}: {'âœ… Presente' if presente else 'âŒ Ausente'}")
        
# ğŸ”¹ GeraÃ§Ã£o do relatÃ³rio final separando TR e ETP
if uploaded_tr or uploaded_etp:
    st.subheader("ğŸ“„ ConclusÃ£o")
    
    if faltantes_tr:
        st.write("ğŸš¨ **Itens ausentes no Termo de ReferÃªncia (TR):**")
        for item in faltantes_tr:
            st.write(f"- âŒ {item}")

    if faltantes_etp:
        st.write("ğŸš¨ **Itens ausentes no Estudo TÃ©cnico Preliminar (ETP):**")
        for item in faltantes_etp:
            st.write(f"- âŒ {item}")

    if not faltantes_tr and not faltantes_etp:
        st.success("âœ… O Termo de ReferÃªncia e o Estudo TÃ©cnico Preliminar estÃ£o completos e podem seguir para a prÃ³xima etapa.")
    else:
        st.warning("âš ï¸ O Termo de ReferÃªncia ou o Estudo TÃ©cnico Preliminar precisam ser corrigidos antes de seguir.")
